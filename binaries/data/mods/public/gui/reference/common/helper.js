var g_CurrentModifiers = {};

function deriveModifications(techList)
{
	let techData = [];
	for (let techName of techList)
		techData.push(GetTechnologyBasicDataHelper(loadTechData(techName), g_SelectedCiv));

	return DeriveModificationsFromTechnologies(techData);
}

/**
 * Provided with an array containing basic information about possible
 * upgrades, such as that generated by globalscript's GetTemplateDataHelper,
 * this function loads the actual template data of the upgrades, overwrites
 * certain values within, then passes an array containing the template data
 * back to caller.
 */
function getActualUpgradeData(upgradesInfo)
{
	let newUpgrades = [];
	for (let upgrade of upgradesInfo)
	{
		upgrade.entity = upgrade.entity.replace("{civ}", g_SelectedCiv);

		let data = GetTemplateDataHelper(loadTemplate(upgrade.entity), null, g_AuraData, g_ResourceData, g_DamageTypes);
		data.cost = upgrade.cost;
		data.icon = upgrade.icon || data.icon;
		data.tooltip = upgrade.tooltip || data.tooltip;
		data.requiredTechnology = upgrade.requiredTechnology || data.requiredTechnology;

		newUpgrades.push(data);
	}
	return newUpgrades;
}

/**
 * Determines and returns the phase in which a given technology can be
 * first researched. Works recursively through the given tech's
 * pre-requisite and superseded techs if necessary.
 *
 * @param {string} techName - The Technology's name
 * @return The name of the phase the technology belongs to, or false if
 *         the current civ can't research this tech
 */
function getPhaseOfTechnology(techName)
{
	let phaseIdx = -1;

	if (basename(techName).startsWith("phase"))
	{
		if (!g_ParsedData.phases[techName].reqs)
			return false;

		phaseIdx = g_ParsedData.phaseList.indexOf(getActualPhase(techName));
		if (phaseIdx > 0)
			return g_ParsedData.phaseList[phaseIdx - 1];
	}

	if (!g_ParsedData.techs[g_SelectedCiv][techName])
	{
		let techData = loadTechnology(techName);
		g_ParsedData.techs[g_SelectedCiv][techName] = techData;
		warn("The \"" + techData.name.generic + "\" technology is not researchable in any structure buildable by the " +
			g_SelectedCiv + " civilisation, but is required by something that this civ can research, train or build!");
	}

	let techReqs = g_ParsedData.techs[g_SelectedCiv][techName].reqs;
	if (!techReqs)
		return false;

	for (let option of techReqs)
		if (option.techs)
			for (let tech of option.techs)
			{
				if (basename(tech).startsWith("phase"))
					return tech;
				if (basename(tech).startsWith("pair"))
					continue;
				phaseIdx = Math.max(phaseIdx, g_ParsedData.phaseList.indexOf(getPhaseOfTechnology(tech)));
			}
	return g_ParsedData.phaseList[phaseIdx] || false;
}

/**
 * Returns the actual phase a certain phase tech represents or stands in for.
 *
 * For example, passing `phase_city_athen` would result in `phase_city`.
 *
 * @param {string} phaseName
 * @return {string}
 */
function getActualPhase(phaseName)
{
	if (g_ParsedData.phases[phaseName])
		return g_ParsedData.phases[phaseName].actualPhase;

	warn("Unrecognised phase (" + phaseName + ")");
	return g_ParsedData.phaseList[0];
}

/**
 * Returns the required phase of a given unit or structure.
 *
 * @param {object} template
 * @return {string}
 */
function getPhaseOfTemplate(template)
{
	if (!template.requiredTechnology)
		return g_ParsedData.phaseList[0];

	if (basename(template.requiredTechnology).startsWith("phase"))
		return getActualPhase(template.requiredTechnology);

	return getPhaseOfTechnology(template.requiredTechnology);
}

/**
 * Determine order of phases.
 *
 * @param {object} techs - The current available store of techs.
 * @return {array} List of phases
 */
function unravelPhases(techs)
{
	let phaseList = [];

	for (let techcode in techs)
	{
		let techdata = techs[techcode];

		if (!techdata.reqs || !techdata.reqs.length || !techdata.reqs[0].techs || techdata.reqs[0].techs.length < 2)
			continue;

		let reqTech = techs[techcode].reqs[0].techs[1];

		if (!techs[reqTech] || !techs[reqTech].reqs.length)
			continue;

		// Assume the first tech to be a phase
		let reqPhase = techs[reqTech].reqs[0].techs[0];
		let myPhase = techs[techcode].reqs[0].techs[0];

		if (reqPhase == myPhase || !basename(reqPhase).startsWith("phase") || !basename(myPhase).startsWith("phase"))
			continue;

		let reqPhasePos = phaseList.indexOf(reqPhase);
		let myPhasePos = phaseList.indexOf(myPhase);

		// Sort the phases in the order they can be researched
		if (!phaseList.length)
			phaseList = [reqPhase, myPhase];
		else if (reqPhasePos < 0 && myPhasePos != -1)
			phaseList.splice(myPhasePos, 0, reqPhase);
		else if (myPhasePos < 0 && reqPhasePos != -1)
			phaseList.splice(reqPhasePos+1, 0, myPhase);
		else if (reqPhasePos > myPhasePos)
		{
			phaseList.splice(reqPhasePos+1, 0, myPhase);
			phaseList.splice(myPhasePos, 1);
		}
		else if (reqPhasePos < 0 && myPhasePos < 0)
			// If neither phase is in the list, then add them both to the end and
			// rely on later iterations relocating them to their correct place.
			phaseList.push(reqPhase, myPhase);
	}

	return phaseList;
}

/**
 * This is needed because getEntityCostTooltip in tooltip.js needs to get
 * the template data of the different wallSet pieces. In the session this
 * function does some caching, but here we do that in loadTemplate already.
 */
function GetTemplateData(templateName)
{
	var template = loadTemplate(templateName);
	return GetTemplateDataHelper(template, null, g_AuraData, g_ResourceData, g_DamageTypes, g_CurrentModifiers);
}

function isPairTech(technologyCode)
{
	return basename(technologyCode).startsWith("pair") || basename(technologyCode).indexOf("_pair") > -1;
}

function mergeRequirements(reqsA, reqsB)
{
	if (reqsA === false || reqsB === false)
		return false;

	let finalReqs = clone(reqsA);

	for (let option of reqsB)
		for (let type in option)
			for (let opt in finalReqs)
			{
				if (!finalReqs[opt][type])
					finalReqs[opt][type] = [];
				finalReqs[opt][type] = finalReqs[opt][type].concat(option[type]);
			}

	return finalReqs;
}
